## 操作系统基础

#### tcp/udp 区别

TCP | UDP
--- | ---
TCP面向连接（如打电话要先拨号建立连接）| UDP是无连接的，即发送数据之前不需要建立连接
TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达 | UDP尽最大努力交付，即不保证可靠交付
TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流 | UDP是面向报文的
--- | UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）
每一条TCP连接只能是点到点的 | UDP支持一对一，一对多，多对一和多对多的交互通信
TCP首部开销20字节 | UDP的首部开销小，只有8个字节
TCP的逻辑通信信道是全双工的可靠信道 | UDP则是不可靠信道

#### 进程与线程的区别
>
> 抽象表述：进程是资源分配的最小单位，线程是cpu调度的最小单位
> 
> 形象比喻 进程=火车，线程=车厢
> 
> 线程在进程下行进（单纯的车厢无法运行）
> 
> 一个进程可以包含多个线程（一辆火车可以有多个车厢）
> 
> 不同进程间数据很难共享（一辆火车上的乘客很难换到另外一辆火车，比如站点换乘）
> 
> 同一进程下不同线程间数据很易共享（A车厢换到B车厢很容易）
> 
> 进程要比线程消耗更多的计算机资源（采用多列火车相比多个车厢更耗资源）
> 
> 进程间不会相互影响，一个线程挂掉将导致整个进程挂掉（一列火车不会影响到另外一列火车，但是如果一列火车上中间的一节车厢着火了，将影响到所有车厢）
> 
> 进程可以拓展到多机，进程最多适合多核（不同火车可以开在多个轨道上，同一火车的车厢不能在行进的不同的轨道上）
> 
> 进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。（比如火车上的洗手间）－"互斥锁"
> 
> 进程使用的内存地址可以限定使用量（比如火车上的餐厅，最多只允许多少人进入，如果满了需要在门口等，等有人出来了才能进去）－“信号量”

#### 在linux上开辟一个虚拟环境venv

> 安装， apt-get install python3-venv
> 
> 创建：python3 venv venc
> 
> 进入虚拟环境： source venv/bin/activate
> 
> 之后就可以在此环境中指定或者定义各种变量，而不会影响到宿主机的正常运行

#### 三次握手和四次挥手

> **三次握手**
>>![image](https://user-images.githubusercontent.com/84756119/120254262-021c9580-c2bc-11eb-985e-68adb101de75.png)

>> 第一次：客户端发送请求到服务器，服务器知道客户端发送，自己接收正常。SYN=1,seq=x

>> 第二次：服务器发给客户端，客户端知道自己发送、接收正常，服务器接收、发送正常。ACK=1,ack=x+1,SYN=1,seq=y

>> 第三次：客户端发给服务器：服务器知道客户端发送，接收正常，自己接收，发送也正常.seq=x+1,ACK=1,ack=y+1
>> 

> **四次挥手**
>> 
>> 第一次挥手：客户端发出释放FIN=1，自己序列号seq=u，进入FIN-WAIT-1状态

>> 第二次挥手：服务器收到客户端的后，发出ACK=1确认标志和客户端的确认号ack=u+1，自己的序列号seq=v，进入CLOSE-WAIT状态

>> 第三次挥手：客户端收到服务器确认结果后，进入FIN-WAIT-2状态。此时服务器发送释放FIN=1信号，确认标志ACK=1，确认序号ack=u+1，自己序号seq=w，服务器进入LAST-ACK（最后确认态）

>> 第四次挥手：客户端收到回复后，发送确认ACK=1，ack=w+1，自己的seq=u+1，客户端进入TIME-WAIT（时间等待）。客户端经过2个最长报文段寿命后，客户端CLOSE；服务器收到确认后，立刻进入CLOSE状态。
>> ![image](https://user-images.githubusercontent.com/84756119/120254155-c5e93500-c2bb-11eb-8cd9-368815680d13.png)

#### 7层网络协议

> 应用层、表示层、会话层、传输层、网络层、数据链路层、物理层

#### dns解析流程

> 1.从浏览器缓存中查找是否存在此域名对应的ip，如存在则跳至第五步；
> 
> 2.如果不存在，则从操作系统的缓存（host表）中查找，存在则至第五步；
> 
> 3.如果仍然不存在，则从本地域名服务器查找此域名对应ip，存在至第五步；
> 
> 4.如果仍然不存在，则跳到Root Server 域名服务器请求解析，根域名服务器将域名所在的域服务器返回给本地域服务器，域服务器往得到的域服务器发送请求；
> 
> 5.得到一个ip地址后向这个ip发送连接请求（tcp/ip建立连接）；
> 
> 6.服务器将此ip的内容通过html格式将数据传递给本地浏览器
> 
> 7.浏览器解析html的内容请求对应的资源
> 
> 8.浏览器将所得资源渲染展示给用户
> 
> 9.关闭连接

#### lsof命令

> 是列出打开文件（lists openfiles）”，而在Unix中一切（包括网络套接口）都是文件，所以lsof基本可以查询到所有的信息，用它来获得你系统上设备的信息，通过它了解到指定的用户在指定的地点正在碰什么东西，或者甚至是一个进程正在使用什么文件或网络连接。
> 
> 有很多的可选参数，部分参数支持+/-
> 
> **lsof -i :portxx**    列出端口portxx当前的网络连接信息
> 
> **lsof -i @hostxx**    显示指定到指定主机hostxx的连接信息
> 
> **lsof -i @hostxx:portxx**    显示基于主机与端口的连接
> 
> **lsof  -i -sTCP:LISTEN**  找出当前正在LISTEN的端口信息（同样的ESTABLISHED等也可以）
> 
> **lsof  -u userxx**    列出当前用户userxx正在打开的信息
> 
> **lsof  -t -u userxx**    列出当前用户userxx正在打开的所有的进程ID
> 
> **lsof  file/dic**    列出与当前目录或者文件交互的所有信息
> 
> **lsof -c abc** 显示abc进程现在打开的文件
