## 操作系统基础

#### tcp/udp 区别

TCP | UDP
--- | ---
TCP面向连接（如打电话要先拨号建立连接）| UDP是无连接的，即发送数据之前不需要建立连接
TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达 | UDP尽最大努力交付，即不保证可靠交付
TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流 | UDP是面向报文的
--- | UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）
每一条TCP连接只能是点到点的 | UDP支持一对一，一对多，多对一和多对多的交互通信
TCP首部开销20字节 | UDP的首部开销小，只有8个字节
TCP的逻辑通信信道是全双工的可靠信道 | UDP则是不可靠信道

#### 进程与线程的区别
>
> 抽象表述：进程是资源分配的最小单位，线程是cpu调度的最小单位
> 
> 形象比喻 进程=火车，线程=车厢
> 
> 线程在进程下行进（单纯的车厢无法运行）
> 
> 一个进程可以包含多个线程（一辆火车可以有多个车厢）
> 
> 不同进程间数据很难共享（一辆火车上的乘客很难换到另外一辆火车，比如站点换乘）
> 
> 同一进程下不同线程间数据很易共享（A车厢换到B车厢很容易）
> 
> 进程要比线程消耗更多的计算机资源（采用多列火车相比多个车厢更耗资源）
> 
> 进程间不会相互影响，一个线程挂掉将导致整个进程挂掉（一列火车不会影响到另外一列火车，但是如果一列火车上中间的一节车厢着火了，将影响到所有车厢）
> 
> 进程可以拓展到多机，进程最多适合多核（不同火车可以开在多个轨道上，同一火车的车厢不能在行进的不同的轨道上）
> 
> 进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。（比如火车上的洗手间）－"互斥锁"
> 
> 进程使用的内存地址可以限定使用量（比如火车上的餐厅，最多只允许多少人进入，如果满了需要在门口等，等有人出来了才能进去）－“信号量”

#### 在linux上开辟一个虚拟环境venv

> 安装， apt-get install python3-venv
> 
> 创建：python3 venv venc
> 
> 进入虚拟环境： source venv/bin/activate
> 
> 之后就可以在此环境中指定或者定义各种变量，而不会影响到宿主机的正常运行

#### 三次握手和四次挥手

> **三次握手**
>>
>> 第一次：客户端发送请求到服务器，服务器知道客户端发送，自己接收正常。SYN=1,seq=x

>> 第二次：服务器发给客户端，客户端知道自己发送、接收正常，服务器接收、发送正常。ACK=1,ack=x+1,SYN=1,seq=y

>> 第三次：客户端发给服务器：服务器知道客户端发送，接收正常，自己接收，发送也正常.seq=x+1,ACK=1,ack=y+1

> **四次挥手**
>> 
>> 第一次挥手：客户端发出释放FIN=1，自己序列号seq=u，进入FIN-WAIT-1状态

>> 第二次挥手：服务器收到客户端的后，发出ACK=1确认标志和客户端的确认号ack=u+1，自己的序列号seq=v，进入CLOSE-WAIT状态

>> 第三次挥手：客户端收到服务器确认结果后，进入FIN-WAIT-2状态。此时服务器发送释放FIN=1信号，确认标志ACK=1，确认序号ack=u+1，自己序号seq=w，服务器进入LAST-ACK（最后确认态）

>> 第四次挥手：客户端收到回复后，发送确认ACK=1，ack=w+1，自己的seq=u+1，客户端进入TIME-WAIT（时间等待）。客户端经过2个最长报文段寿命后，客户端CLOSE；服务器收到确认后，立刻进入CLOSE状态。
